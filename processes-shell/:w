#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define EXIT "exit"
#define PATH "path"
#define CD "cd"
#define USRBIN "/usr/bin/"
#define BIN "/bin/"

char *prepend(const char *restrict, const char *restrict);
char **tokenize(const char *, const char *, size_t *);
int execute(char **);
void err_routine(bool);
void free_tokens(char **);


int main(int argc, char *argv[]) {
	char *line = NULL;
	size_t linecap = 0;
	int linelen = 0;
	const char *delims = " \t\n";
	FILE *fp = stdin;
	bool batch = (argc > 1);
	
	// special case: batch mode
	if (batch) {
		fp = fopen(argv[1], "r");
		if (fp == NULL) {
			err_routine(true);
		}
	}
	
	char **tokens = malloc(0);
	tokens[0] = NULL;
	size_t nargs = 0;
	while (true) {
		free_tokens(tokens);
		if (!batch) printf("wish> ");
		if ((linelen = getline(&line, &linecap, fp)) < 0) {
			exit(0);
		}	
	
		tokens = tokenize(line, delims, &nargs);
		char *cmd = tokens[0]; // TODO rename this

		// first check for built-ins
		if (strcmp(cmd, EXIT) == 0) {
			if (nargs > 1) {
				err_routine(false);
			} else {
				free_tokens(tokens);
				free(line);
				exit(0);
			}
		} else if (strcmp(cmd, CD) == 0) {
			if (nargs != 2 || chdir(tokens[1]) < 0) {
				err_routine(false);
			}
		} else if (strcmp(cmd, PATH) == 0) {
			// TODO
		}

		// not a built-in command, call from path
		else {
			int rc = fork();
			if (rc < 0) {
				err_routine(true);
			}
			// child [DEBUG: parent]
			else if (rc == 0) {
				if ((execute(tokens) == -1)) {
					free_tokens(tokens);
					err_routine(true);
				}
			}
			// parent
			else {					
				wait(NULL);
			}
		}
	}
}


void err_routine(bool call_exit) {
	// fprintf(stderr, "An error has occurred\n");
	char error_message[30] = "An error has occurred\n";
	write(STDERR_FILENO, error_message, strlen(error_message)); 
	if (call_exit) exit(1);
}

// TODO loop over paths
int execute(char **args, char **path) {
	for (char *p = path[0]; *p != NULL; ++p) {
		char *prepended = prepend(path, args[0]);
		if (access(prepended, X_OK)) {
			// args must contain p
			free(args[0]);
			args[0] = p;
		}
	}
	// prepend /bin/cmd
	char *p = prepend(args[0], BIN);

	// only try /usr/bin if /bin fails
	if (access(p, X_OK) != 0) {
		free(p);
		p = prepend(args[0], USRBIN);
		if (access(p, X_OK) != 0) {
			free(p);
			return -1;
		}
	}

	// args[0] must match p
	free(args[0]);
	args[0] = p;

	return execv(p, args);
}


char *prepend(const char *restrict base, const char *restrict prefix) {
	char *s = malloc(strlen(prefix) + strlen(base) + 1);
	strcpy(s, prefix);
	strcat(s, base);

	return s;
}


char **tokenize(const char *line, const char *delims, size_t *nargs) {
	// count number of args
	*nargs = 0;
	const char *p = line;
	while (*p != '\0') {
		p += strcspn(p, delims);
		p += strspn(p, delims);
		*nargs += 1;
	}
	// tokenize args (final arg must be NULL for execv)
	char **tokens = malloc((*nargs + 1) * sizeof(char *));
	char *token, *tofree, *linedup; 
	tofree = linedup = strdup(line);
	int i = 0;
	while ((token = strsep(&linedup, delims)) != NULL) {
		// ensure token is not delimiter
		if (strlen(token) > 0) {
			tokens[i] = strdup(token);
			i++;
		}
	} 
	tokens[i] = NULL;
	free(tofree);

	return tokens;
}


void free_tokens(char **tokens) {
	for (char **p = tokens; *p != NULL; p++) {
		free(*p);
	}
	free(tokens);
}
